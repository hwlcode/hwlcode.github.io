{"meta":{"title":"一叶知秋","subtitle":"前端工程师","description":"没有办法消除混乱，我们只是让某些局部变得更有秩序，把混乱转移到另一些领域.","author":"hwlcode","url":"http://yoursite.com"},"pages":[{"title":"Categories","date":"2017-08-14T09:50:01.000Z","updated":"2017-08-14T09:28:30.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-08-14T09:50:01.000Z","updated":"2017-08-14T09:28:30.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2017-08-14T09:50:01.000Z","updated":"2017-08-14T09:28:30.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"在Mac平台下搭建WebStorm+PhoneGap/Cordova开发App应用","slug":"在Mac平台下搭建WebStorm-PhoneGap-Cordova开发App应用","date":"2017-07-24T06:50:01.000Z","updated":"2017-08-14T13:11:37.000Z","comments":true,"path":"2017/07/24/在Mac平台下搭建WebStorm-PhoneGap-Cordova开发App应用/","link":"","permalink":"http://yoursite.com/2017/07/24/在Mac平台下搭建WebStorm-PhoneGap-Cordova开发App应用/","excerpt":"本文介绍下如何在Mac环境下WebStorm配置PhoneGap/Cordova,以及配置Android,iOS模拟器生成预览,并为程序签名。","text":"本文介绍下如何在Mac环境下WebStorm配置PhoneGap/Cordova,以及配置Android,iOS模拟器生成预览,并为程序签名。 环境准备1、首先请确保您的Mac上装有最新版本的JDK。请到：http://www.oracle.com/technetwork/java/javase/downloads/index.html 下载2、本地己经安装最新版的nodejs 安装cordova打开终端，在root用户下输入以下命令： 1npm install -- global cordova 安装模拟器Mac (使用XCode模拟器)由于在Mac平台上开发，Mac里面的XCode已经有模拟器了，所以只需下载ios-sim这个插件就能从WebStorm顺利调出iOs的模拟器。请到：https://github.com/phonegap/ios-sim 下载并安装iOS-sim (或在终端输入： sudo npm install ios-sim -g); Andriod1、下载SDK android模拟器的配置要稍微复杂一些。需要安装Android SDK,(请到：http://www.android-studio.org/ 下载)，可根据需要下载独立的Android SDK. 如果想方便管理SDK，那么推荐下载 Android Studio (推荐). 在Android Studio菜单栏里找到SDK manager 点击，打开。下载一个SDK,比如：Android 5.1.1(在这个栏目下找到SDK Platform,打勾，并下载安装，记住SDK的api号是22，一会项目会用到，下载地址是来自google的，所以你需要一个梯子)。 2、加入.bash_profile 安装完Android sdk, 如果要在WebStorm调出模拟器，还需要一个步骤，把idk路径添加到.bash_profile： 在~/.bash_profile中添加 123export PATH=$&#123;PATH&#125;:/Users/你的用户/library/Android/sdk/platform-tools:/Users/你的用户/library/Android/sdk/tools//更新你的配置source ~/.bash_profile WebStorm里面可以确认需要的npm包是否己经安装了 进入：WebStorm -&gt; Preferences -&gt; Languages &amp; Frameworks -&gt; Node.js and NPM , 应该有的Package应如下图所示，如果没有，要选择下面的 “＋” 选择安装： 进入javascript -&gt; PhoneGap/Cordova, 配置应为下图所示界面，其中PhoneGap/Cordova working directory 应为你的新建的工程项目路径。 PhoneGap/Cordova executable: /usr/local/bin/cordova 应选择cordova,不选phonegap! 3、gradle配置gradle是andriod用来打包的，通常在编辑项目的时候会去下载相匹配的gradle版本，而且地址来自google的源，会被墙掉，可以以手动的方式来配置过程可以参考一个大神的笔记： Android Studio手动配置Gradle的方法 新建项目好了，新建一个PhoneGap/Cordova的项目试试吧 新建项目后，打开Plateforms/android, 打开project.properties, 确保 target=android-26，如果您下载的是Android SDK 8.0,那么target=android-26. 选择WebStorm的菜单Run/Edit Configurations, 这个页面就是让您选择使用iOs模拟器还是Android模拟器，可以选择 “Show this page”,这样，每次点运行就能出这个页面来选择不同的模拟器。Command选择：emulate . 在点击run前可以选运行一下环境检测命令 12345678910111213# cordova requirements Requirements check results for android:Java JDK: installed 1.8.0Android SDK: installed trueAndroid target: installed android-26,android-25Gradle: installed /Applications/Android Studio.app/Contents/gradle/gradle-3.2/bin/gradleRequirements check results for ios:Apple OS X: installed darwinXcode: installed 8.1ios-deploy: installed 1.9.1CocoaPods: not installed 如果没有报错或警告，就可以分别在iOs,和Android上模拟了。pod setup 安装 补充andriod stdio 自带的avd模拟器，性能比较的差，一般会采用genymotion 安装 genymotion1、官网先下载Genymotion：http://www.genymotion.com/,下载完成后安装好，同时你需要在genymotion官网上注册一个账号，这样你才能正常的使用genymotion。 2、启动genymotion。然后选择添加你所要的设备。点add后会出现genymotion支持的所有设备列表，选择你需要的进行下载即可，下载好了就会出现在Your virtual devices列表中。 3、android Studio中安装Genymotion插件，注意哈，这边要搜索的插件的名称就是genymotion。 4、安装好Genymotion插件后，在设置页面就会出现Genymotion选项了，然后进行配置地址，地址只要指到安装的根目录即可。 5、配置完成后，你再点击上图中的红色按钮，这个时候就可以读取到所有安装好的模拟器了。 报错解决办法1、Genymotion报错”virtualbox cannot start the virtual device”解决方法 a. 检查IP地址是否正确 依次打开: 管理-全局设定-网络-主机虚拟网络界面，查看ip是否为192.168.56.1，据说必须是这个ip。 b. 检查Configuration设置 打开Genymotion，点击下图中设置图标，打开Configuration 检查Processor(s)，修改成合适的值。 检查Base Memory(MB)，修改成合适的值 2、could not install smartsocket listener: Address already in use 错误原因是选择了使用Genymotion的Android tools，所以导致与android SDK下的adb程序冲突。 在Genymotion的主界面点击【Settings】 选择【Use custom Android SDK tools】，然后选择Androd SDK根目录 重启Genymotion的虚拟机即可解决问题。 签名发布iOS平台先说简单的，给iOs平台签名，可以在 ／您的项目路径／platforms/ ios/ 下面找到一个 “项目名.xcodeproj”文件，双击用XCode打开，在Xcode的build setting里设置分发签名，然后在菜单选择Product/Build,就可以在左边树图最下面找到Products/你的项目名称.app 文件，这个就是最终可以发布的app文件。 Android平台在WebStorm点击运行后，WebStorm就会在项目的platforms/android/build/outputs/apk 文件夹里生成android-debug.apk,android-debug-unsigned.apk,android-debug-unaligned.apk文件。这些都是没有经过签名的文件，需要签名才能发布。 1.先生成一个keystore: 打开终端，输入：cd /library/Java/home/bin/ 然后输入： keytool -genkey -v -keystore android.keystore -alias android -keyalg RSA -validity 20000 -keystore /Users/你的用户名/android.keystore 回车后，就在/Users/你的用户名/ 下生成了一个android.keystore 文件。 2.在WebStorm里创建两个扩展命令工具： a: 打开WebStorm菜单的Run/Edit Configurations,如下图所示：点击 “＋”选择“Run External tool”添加扩展命令。 运行这个命令就会在apk文件夹下生成：android-release-unsigned.apk 用同样的方法再创建一个扩展命令： 这次将使用jarsigner命令和刚才创建的android.keystore来为android-release-unsigned.apk签名， Program上填:jarsigner Parameters上填： -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore /Users/您的用户名/android.keystore platforms/android/build/outputs/apk/android-release-unsigned.apk android红色部分根据自己项目的要求填写。最后红色的android是keystore的别名。 Working directory:填当前的项目路径。 运行这个扩展命令后，android-release-unsigned.apk虽然名字不变，但已经是签过名的文件了，可以对外发布了。 这些扩展命令可以用鼠标右键点击WebStorm左边项目的树图，然后找到External tools,分别执行，非常方便。","categories":[],"tags":[]},{"title":"mongoose 实现关联表的查询","slug":"mongoose-实现关联表的查询","date":"2017-07-20T04:10:01.000Z","updated":"2017-08-14T13:11:53.000Z","comments":true,"path":"2017/07/20/mongoose-实现关联表的查询/","link":"","permalink":"http://yoursite.com/2017/07/20/mongoose-实现关联表的查询/","excerpt":"因为MongoDB是文档型数据库，所以它没有关系型数据库joins(数据库的两张表通过”外键”，建立连接关系。) 特性。也就是在建立数据的关联时会比较麻烦。为了解决这个问题，Mongoose封装了一个Population功能。使用Population可以实现在一个 document 中填充其他 collection(s) 的 document(s)。","text":"因为MongoDB是文档型数据库，所以它没有关系型数据库joins(数据库的两张表通过”外键”，建立连接关系。) 特性。也就是在建立数据的关联时会比较麻烦。为了解决这个问题，Mongoose封装了一个Population功能。使用Population可以实现在一个 document 中填充其他 collection(s) 的 document(s)。 先建三个Schema和model: 1234567891011121314151617181920212223242526272829303132333435363738394041424344var mongoose = require(&quot;mongoose&quot;);var Schema = mongoose.Schema;var ArticleSchema = new Schema(&#123; title: &#123; type:String&#125;, discription: &#123;type: String&#125;, post:&#123;type:String&#125;, thumbnail: &#123;type: String, default:&apos;&apos;&#125;, pv: &#123; type:Number, default: 0&#125;, poster: &#123; type: Schema.Types.ObjectId, ref: &apos;User&apos; &#125;, //has one topics:[&#123; type: Schema.Types.ObjectId, ref: &apos;Label&apos; &#125;] //has many &#125;, &#123; timestamps: true &#125;);mongoose.model(&apos;Article&apos;, ArticleSchema);var labelSchema = new Schema(&#123; articleId: [&#123;type: mongoose.Schema.Types.ObjectId, ref: &apos;Article&apos;&#125;], //has many label: &#123;type: String&#125; &#125;, &#123; timestamps: true &#125;);mongoose.model(&apos;Label&apos;, labelSchema);var UserSchema = new Schema(&#123; username: &#123; type:String&#125;, password: &#123; type:String, default: null&#125;, avatar: &#123;type: String&#125;, email: &#123; type:String&#125;, isAdmin:&#123; type:Boolean, default: null&#125;, sourceType:&#123; type:String&#125;, sourceTypeId:&#123; type:String&#125;, posts : [&#123; type: Schema.Types.ObjectId, ref: &apos;Article&apos; &#125;] //has many &#125;, &#123; timestamps: true &#125;);mongoose.model(&apos;User&apos;, UserSchema); 创建了三个Models: Article, Label, User User 的属性 posts，对应是一个 ObjectId 的数组。ref表示关联Post(注意: 被关联的model的 type 必须是 ObjectId, Number, String, 和 Buffer 才有效)。 Article的属性 poster 和 topics 分别关联User和Label。 Label的属性 articleId 分别关联Article。 三个 Models 的关系:一个 user–has many–&gt;article。一个 article–has one–&gt;user，has many–&gt; topics。一个 label–has many–&gt;article。 注：一对一用{}，一对多用[{}] 插入数据12345678910111213141516171819var onelabel = yield LabelModel.findOne(&#123; label:posts.tags&#125;).exec();if(onelabel == null) &#123; //新标签 var onelableObj = yield LabelModel.create(&#123; articleId: post._id, label: posts.tags &#125;); post.topics.push(onelableObj._id); yield post.save();&#125;else&#123; //己存在相同标签 onelabel.articleId.push(post._id); yield onelabel.save(); post.topics.push(onelabel._id); yield post.save();&#125; 用push和save的方式实现，注册插入的字段类型要对应上 关联查询1234567891011121314151617181920212223let article = yield ArticleModel.findOne(&#123;_id:id&#125;).exec(function(err,doc)&#123; var opts = [&#123; path : &apos;poster&apos;, select : &apos;username&apos; &#125;,&#123; path : &apos;topics&apos;, select : &apos;label&apos; &#125;]; doc.populate(opts, function(err, populatedDoc) &#123; console.log(populatedDoc); populatedDoc.created = moment(new Date(populatedDoc.createdAt)).fromNow(); res.render(&apos;article&apos;, &#123; article: populatedDoc, title: populatedDoc.title, tag: populatedDoc.topics, user: req.session.user || null &#125;) &#125;);&#125;); 关键方法populate的使用 Document.populate([path], [callback]) path: 关联字段 select: 联表需要显示的内容 结果示例 1234567891011121314&#123; _id: 596ee023793d184e18620d5a, updatedAt: 2017-07-19T04:53:29.786Z, createdAt: 2017-07-19T04:29:23.022Z, title: &apos;1&apos;, discription: &apos;11&apos;, post: &apos;&lt;p&gt;111&lt;/p&gt;\\n&apos;, poster: &#123; _id: 596ed299d2e1204b2444a95c, username: &apos;weiliang.hwl&apos; &#125;, __v: 3, topics: [ &#123; _id: 596ed5b7d621874c142ed096, label: &apos;nodejs&apos; &#125;, &#123; _id: 596ee023793d184e18620d5b, label: &apos;aaab&apos; &#125;, &#123; _id: 596ee023793d184e18620d5c, label: &apos;ccc&apos; &#125; ], pv: 1, thumbnail: &apos;/img/logo_32_32.png&apos; &#125; 多级嵌套的populate处理数据在populate里面再接入一个populate的处里，而不是在exec里面populate 12345678910yield LabelModel.findOne(&#123;_id: id&#125;).populate(&#123; path: &apos;articleId&apos;, populate: [&#123; path : &apos;poster&apos; &#125;,&#123; path : &apos;topics&apos; &#125;]&#125;).exec(function (err, docPopulate) &#123;&#125;);","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]},{"title":"nodejs如何支持es7","slug":"nodejs如何支持es7","date":"2017-07-05T10:06:22.000Z","updated":"2017-08-14T13:11:59.000Z","comments":true,"path":"2017/07/05/nodejs如何支持es7/","link":"","permalink":"http://yoursite.com/2017/07/05/nodejs如何支持es7/","excerpt":"第一步12npm install --save-dev babel-cli npm install --save-dev babel-preset-es2015 babel-preset-es2017","text":"第一步12npm install --save-dev babel-cli npm install --save-dev babel-preset-es2015 babel-preset-es2017 第二步在package.json中增加 123&quot;babel&quot;:&#123; &quot;presets&quot;: [&quot;es2015&quot;,&quot;es2017&quot;]&#125;, 第三步用babel-node启动应用 1babel-node app.js","categories":[],"tags":[]},{"title":"阿里云服务器安装最新版的nodejs","slug":"阿里云服务器安装最新版的nodejs","date":"2017-07-04T15:33:14.000Z","updated":"2017-08-14T13:10:31.000Z","comments":true,"path":"2017/07/04/阿里云服务器安装最新版的nodejs/","link":"","permalink":"http://yoursite.com/2017/07/04/阿里云服务器安装最新版的nodejs/","excerpt":"第一步: 在阿里云管理控制台把服务器启动起来. 第二步: ssh 登录服务器 ssh root@你的公网IP","text":"第一步: 在阿里云管理控制台把服务器启动起来. 第二步: ssh 登录服务器 ssh root@你的公网IP 第三步: yum 首先更新一下 1yum -y update 第四步: centOS 系统下编译源代码的一些开发工具,我们一起安装了. 1yum -y groupinstall &quot;Development Tools&quot; 第五步: 选择一个稳定的node.js 版本. 我的开发环境,生产环境都是 v6.11.0 1wget https://nodejs.org/dist/v6.11.0/node-v6.11.0.tar.gz 接着解压: 1tar zxvf node-v6.11.0.tar.gz 进入解压目录: 1cd node-v6.11.0 预编译: 1./configure --prefix=/home/node/6.11.0 编译: 1make install 第五步: 安装成功以后,配置一个系统环境变量 12echo &quot;export PATH=$PATH:/home/node/6.11.0/bin&quot; &gt;&gt; ~/.bash_profilesource ~/.bash_profile 上面这一步做的操作是首先打开 root 根目录下的 .bash_profile 文件,然后把 1/home/node/6.11.0/bin 添加到了系统环境变量,然后更新系统环境变量 $PATH 你可以通过下面命令来看下是否添加进去 1echo $PATH 第六步: 看看node 变量是否生效: 12node --versionv6.11.0 看到上面说明环境变量生效. 到这里,整个node.js 环境安装全部完成.","categories":[],"tags":[]},{"title":"阿里云CentOS7安装Mongodb3.2","slug":"阿里云CentOS7安装Mongodb3-2","date":"2017-07-04T15:27:05.000Z","updated":"2017-08-14T13:11:11.000Z","comments":true,"path":"2017/07/04/阿里云CentOS7安装Mongodb3-2/","link":"","permalink":"http://yoursite.com/2017/07/04/阿里云CentOS7安装Mongodb3-2/","excerpt":"１、首先更新一下包吧，多更无害。 1sudo yum -y update 2、在/etc/yum.repos.d 创建一个 mongodb-org.repo 文件","text":"１、首先更新一下包吧，多更无害。 1sudo yum -y update 2、在/etc/yum.repos.d 创建一个 mongodb-org.repo 文件 1sudo touch /etc/yum.repos.d/mongodb-org.repo 3、编辑 mongodb-org.repo 文件 1sudo vi /etc/yum.repos.d/mongodb-org.repo 4、输入以下内容后 保存退出 12345[mongodb-org]name=MongoDB Repositorybaseurl=http://mirrors.aliyun.com/mongodb/yum/redhat/7Server/mongodb-org/3.2/x86_64/gpgcheck=0enabled=1 5、安装MongoDB 1sudo yum install -y mongodb-org 6、启动MongoDB 1sudo service mongod start 7、设置开机启动 1sudo chkconfig mongod on 8、打开MongoDB 1sudo /bin/mongo 9、配置远程访问 编辑 /etc/mongod.conf 注释 bindIp: 127.0.0.1 重启 1sudo service mongod restart","categories":[],"tags":[]},{"title":"github passport应用","slug":"github passport 应用","date":"2017-07-03T15:27:05.000Z","updated":"2017-08-14T13:11:44.000Z","comments":true,"path":"2017/07/03/github passport 应用/","link":"","permalink":"http://yoursite.com/2017/07/03/github passport 应用/","excerpt":"AuthorizationError: The redirect_uri MUST match the registered callback URL for this application.","text":"AuthorizationError: The redirect_uri MUST match the registered callback URL for this application. 1234567891011121314151617passport.use(new GitHubStrategy(&#123; clientID: &apos;8124f1a72802b1b263f1&apos;, clientSecret: &apos;1150500f6b5e1fa2c29af050d9904d1b05c38493&apos;, callbackURL: &quot;/auth/github/callback&quot; &#125;, function(accessToken, refreshToken, profile, done) &#123; // asynchronous verification, for effect... process.nextTick(function () &#123; // To keep the example simple, the user&apos;s GitHub profile is returned to // represent the logged-in user. In a typical application, you would want // to associate the GitHub account with a user record in your database, // and return that user instead. return done(null, profile); &#125;); &#125;)); 此外的callbackURL必须与gitapp上的配置一致！ failed to serialize user into session 1234567passport.serializeUser(function(user, done) &#123; done(null, user);&#125;);passport.deserializeUser(function(user, done) &#123; done(null, user);&#125;); Failed to fetch user profile（http://127.0.0.1:8080/auth/github/callback?code=805ec6de8f994bc7594e） 1域名地址不能访问","categories":[],"tags":[]},{"title":"webpack","slug":"webpack 使用笔记","date":"2017-05-26T08:38:49.000Z","updated":"2017-08-14T13:12:19.000Z","comments":true,"path":"2017/05/26/webpack 使用笔记/","link":"","permalink":"http://yoursite.com/2017/05/26/webpack 使用笔记/","excerpt":"文档https://doc.webpack-china.org/configuration/","text":"文档https://doc.webpack-china.org/configuration/ 安装12npm initnpm install webpack --save-dev 运行原理生成webpack所需的一些模块，然后给生成文件一个序，采用CommonJs的方式，引用序号 小技巧1require(&apos;style-loader!css-loader!./style.css&apos;) //!表示链式的写法 配置基本配置： 123456789var path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./src/js/main.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;./dist/js&apos;), filename: &apos;bundle.js&apos; &#125;&#125;; entry 三种使用方式 123456entry: &apos;./src/js/main.js&apos; //只有一个入口文件entry: [&apos;./src/js/main.js&apos;, &apos;./src/js/main_1.js&apos;] //多个不相干的入口文件entry:&#123; //多页面应用时用 page1: &apos;./page1&apos;, page2: [&apos;./page1&apos;, &apos;./page2&apos;]&#125; output 1234567output: &#123; path: path.resolve(__dirname, &apos;./dist/js&apos;), filename: &apos;[name]-[chunkhash].js&apos; &#125; hash: 无论怎样都变化chunkhash: 改过的文件才变化 运行参数1234567--module-bind=&quot;css-loader&quot; //loader绑定--watch //自动打包--progress //打包过程--display-modules //打包模块--display-reasons //打包的原因--config //指定运行的webpack配置文件--colors //以彩色显示 可以在npm script 里面配置 一些loader的介绍loader处理是从右到左，这一点要注意 css-loader：webpack可以处理.css的文件 style-loader: 把处理完的文件，会在head里面插入，这样就可以运行了 postcss-loader: 样式后处理，如加上样式的各浏览器的前缀，检查css file-loader 处理图片，tpl中的图片用require的方式处理 url-loader 比file-loader多了一个limt参数 image-webpack-loader 图片压缩，最好与file-loader或url-loader一起使用 一些插件的介绍html-webpack-plugin: 解决生成文件的hash值的自动更新问题","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]}]}